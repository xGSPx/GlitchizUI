--[[
    GlitchizUI v5.0 (Simplified & Refactored)
    - The entire library has been rewritten for maximum readability and clarity.
    - Functionality is identical to the last stable version, but the code is now easy to understand and modify.
    - All previous bug fixes (header buttons, tab content, slider, dropdowns, etc.) are included in this clean build.
--]]

local Library = {}
Library.__index = Library

-- // Theme Configuration
local Theme = {
    Background = Color3.fromRGB(20, 18, 28),      
    Header = Color3.fromRGB(45, 35, 65),          
    Accent = Color3.fromRGB(110, 70, 220),        
    Accent2 = Color3.fromRGB(0, 240, 255),        
    Text = Color3.fromRGB(255, 255, 255),         
    Font = Enum.Font.SourceSans,
    BoldFont = Enum.Font.SourceSansBold,
    TextSize = 14,
}

-- // Main Window Constructor
function Library.new(properties)
    local self = setmetatable({}, Library)

    -- // Services are loaded inside .new() to prevent timing-related startup crashes.
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local CoreGui = game:GetService("CoreGui")

    -- // Helper function to create new instances with properties
    local function Create(instanceType, props) 
        local instance = Instance.new(instanceType)
        for property, value in pairs(props or {}) do
            instance[property] = value
        end
        return instance
    end

    -- // Helper function for animations
    local function Animate(instance, newProperties, duration) 
        local tweenInfo = TweenInfo.new(duration or 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(instance, tweenInfo, newProperties)
        tween:Play()
        return tween
    end

    -- // Helper function to make a frame draggable
    local function MakeDraggable(object, handle)
        local isDragging = false
        local dragStart, objectStartPos

        handle.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true
                dragStart = input.Position
                objectStartPos = object.Position
                
                local connection 
                connection = input.Changed:Connect(function() 
                    if input.UserInputState == Enum.UserInputState.End then 
                        isDragging = false 
                        connection:Disconnect() 
                    end 
                end)
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - dragStart
                object.Position = UDim2.new(objectStartPos.X.Scale, objectStartPos.X.Offset + delta.X, objectStartPos.Y.Scale, objectStartPos.Y.Offset + delta.Y)
            end
        end)
    end

    -- // Initialize Window Properties
    self.Title = properties.Title or "GlitchizUI"
    self.Tabs = {}
    self.Keybind = properties.Keybind or Enum.KeyCode.RightControl
    
    local isMobile = UserInputService.TouchEnabled and workspace.CurrentCamera.ViewportSize.X < 700
    self.Size = isMobile and UDim2.new(0.9, 0, 0.65, 0) or (properties.Size or UDim2.new(0, 550, 0, 350))

    -- // Create Core UI Structure
    self.ScreenGui = Create("ScreenGui", {
        Name = "GlitchizUI_ScreenGui",
        ZIndexBehavior = Enum.ZIndexBehavior.Global,
        Parent = CoreGui
    })
    
    self.MainFrame = Create("Frame", {
        Name = "MainFrame",
        Size = self.Size,
        Position = properties.Position or UDim2.new(0.5, -self.Size.X.Offset / 2, 0.5, -self.Size.Y.Offset / 2),
        BackgroundColor3 = Theme.Background,
        BackgroundTransparency = 0.15,
        BorderSizePixel = 0,
        Parent = self.ScreenGui
    })
    Create("UICorner", { CornerRadius = UDim.new(0, 6), Parent = self.MainFrame })
    Create("UIStroke", { Color = Theme.Accent2, Transparency = 0.7, Thickness = 1.5, Parent = self.MainFrame })

    -- // Create Header (ZIndex 2 to always be on top)
    local header = Create("Frame", { Name = "Header", Size = UDim2.new(1, 0, 0, 40), BackgroundColor3 = Theme.Header, BackgroundTransparency = 0.2, BorderSizePixel = 0, ZIndex = 2, Parent = self.MainFrame })
    local dragFrame = Create("Frame", {Name = "DragFrame", Size = UDim2.new(1, -60, 1, 0), BackgroundTransparency = 1, Parent = header})
    Create("TextLabel", { Name = "Title", Size = UDim2.new(1, 0, 1, 0), Position = UDim2.new(0, 15, 0, 0), Text = self.Title, Font = Theme.BoldFont, TextSize = Theme.TextSize + 4, TextColor3 = Theme.Text, TextXAlignment = Enum.TextXAlignment.Left, BackgroundTransparency = 1, Parent = dragFrame })
    
    -- // Create Header Controls (Minimize, Close)
    local controls = Create("Frame", { Name = "Controls", Size = UDim2.new(0, 60, 1, 0), Position = UDim2.new(1, -60, 0, 0), BackgroundTransparency = 1, Parent = header })
    local hideButton = Create("TextButton", { Name = "HideButton", Size = UDim2.new(0, 30, 1, 0), BackgroundColor3 = Color3.new(), BackgroundTransparency = 1, Text = "—", Font = Theme.BoldFont, TextSize = 16, TextColor3 = Theme.Text, Parent = controls })
    local deleteButton = Create("TextButton", { Name = "DeleteButton", Size = UDim2.new(0, 30, 1, 0), Position = UDim2.new(0, 30, 0, 0), BackgroundColor3 = Color3.new(), BackgroundTransparency = 1, Text = "✕", Font = Theme.BoldFont, TextSize = 16, TextColor3 = Theme.Text, Parent = controls })
    
    -- // Create Main Content Area (ZIndex 1 to be below header)
    local contentContainer = Create("Frame", { Name = "ContentContainer", Size = UDim2.new(1, 0, 1, -40), Position = UDim2.new(0, 0, 0, 40), BackgroundTransparency = 1, ZIndex = 1, Parent = self.MainFrame })
    local tabContainer
    if isMobile then
        tabContainer = Create("ScrollingFrame", { Name = "TabContainer", Size = UDim2.new(1, 0, 0, 35), BackgroundColor3 = Theme.Background, BackgroundTransparency = 0.3, BorderSizePixel = 0, ScrollingDirection = Enum.ScrollingDirection.X, ScrollBarThickness = 0, Parent = contentContainer })
        Create("UIListLayout", { FillDirection = Enum.FillDirection.Horizontal, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 5), VerticalAlignment = Enum.VerticalAlignment.Center, Parent = tabContainer })
        self.ContentFrame = Create("Frame", { Name = "ContentFrame", Size = UDim2.new(1, 0, 1, -35), Position = UDim2.new(0, 0, 0, 35), BackgroundTransparency = 1, ClipsDescendants = true, Parent = contentContainer})
    else
        tabContainer = Create("ScrollingFrame", { Name = "TabContainer", Size = UDim2.new(0, 120, 1, 0), BackgroundColor3 = Theme.Background, BackgroundTransparency = 0.3, BorderSizePixel = 0, ScrollingDirection = Enum.ScrollingDirection.Y, ScrollBarThickness = 2, Parent = contentContainer })
        Create("UIListLayout", { FillDirection = Enum.FillDirection.Vertical, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 5), HorizontalAlignment = Enum.HorizontalAlignment.Center, Parent = tabContainer })
        self.ContentFrame = Create("Frame", { Name = "ContentFrame", Size = UDim2.new(1, -120, 1, 0), Position = UDim2.new(0, 120, 0, 0), BackgroundTransparency = 1, ClipsDescendants = true, Parent = contentContainer})
    end

    -- // Connect Core Window Events
    MakeDraggable(self.MainFrame, dragFrame)
    
    function self:Destroy() if self.ScreenGui then self.ScreenGui:Destroy() end; for i,v in pairs(self) do self[i]=nil; setmetatable(self, nil) end end
    local isContentVisible = true
    local function ToggleMinimize()
        isContentVisible = not isContentVisible
        contentContainer.Visible = isContentVisible
        Animate(self.MainFrame, { Size = isContentVisible and self.Size or UDim2.new(self.Size.X.Scale, self.Size.X.Offset, 0, 40) }, 0.2)
        hideButton.Text = isContentVisible and "—" or "+"
    end
    hideButton.MouseButton1Click:Connect(ToggleMinimize)
    deleteButton.MouseButton1Click:Connect(function() self:Destroy() end)
    
    local function ToggleVisibility() self.MainFrame.Visible = not self.MainFrame.Visible end
    UserInputService.InputBegan:Connect(function(input, gameProcessed) 
        if not gameProcessed and input.KeyCode == self.Keybind then 
            ToggleVisibility() 
        end 
    end)
    
    -- // Tab Management Functions
    local isTweeningTab = false
    function self:AddTab(name)
        self.CurrentTabForCreation = nil -- Reset context for element creation
        local newTab = { ElementOffset = 0 }
        
        local buttonSize = isMobile and UDim2.new(0, 100, 1, -10) or UDim2.new(1, -10, 0, 30)
        newTab.Button = Create("TextButton", { Name = name, Size = buttonSize, Text = name, Font = Theme.BoldFont, TextSize = Theme.TextSize, TextColor3 = Theme.Text, BackgroundColor3 = Theme.Header, BorderSizePixel = 0, LayoutOrder = #self.Tabs + 1, Parent = tabContainer })
        Create("UICorner", { CornerRadius = UDim.new(0, 4), Parent = newTab.Button })
        
        local indicatorSize = isMobile and UDim2.new(0.6, 0, 0, 3) or UDim2.new(0, 3, 0.6, 0)
        local indicatorPos = isMobile and UDim2.new(0.2, 0, 1, -3) or UDim2.new(0, 0, 0.2, 0)
        newTab.Indicator = Create("Frame", { Name = "Indicator", Size = indicatorSize, Position = indicatorPos, BackgroundColor3 = Theme.Accent2, BorderSizePixel = 0, Visible = false, Parent = newTab.Button })
        Create("UICorner", { Parent = newTab.Indicator })

        newTab.Frame = Create("ScrollingFrame", { Name = name .. "_Content", Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 1, BorderSizePixel = 0, CanvasSize = UDim2.new(0, 0, 0, 0), ScrollBarImageColor3 = Theme.Accent2, ScrollBarThickness = 4, Parent = self.ContentFrame, Visible = false })
        Create("UIListLayout", { FillDirection = Enum.FillDirection.Vertical, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10), HorizontalAlignment = Enum.HorizontalAlignment.Left, Parent = newTab.Frame })
        Create("UIPadding", {PaddingTop = UDim.new(0, 15), PaddingLeft = UDim.new(0, 15), Parent = newTab.Frame})
        
        newTab.Button.MouseButton1Click:Connect(function()
            if self.ActiveTab == newTab or isTweeningTab then return end
            isTweeningTab = true
            
            local oldTab = self.ActiveTab
            if oldTab then 
                oldTab.Button.BackgroundColor3 = Theme.Header
                oldTab.Indicator.Visible = false
                Animate(oldTab.Frame, {Position = UDim2.new(-1, 0, 0, 0)}, 0.2)
            end
            
            newTab.Frame.Position = UDim2.new(1, 0, 0, 0)
            newTab.Frame.Visible = true
            newTab.Button.BackgroundColor3 = Theme.Accent
            newTab.Indicator.Visible = true
            
            Animate(newTab.Frame, {Position = UDim2.new(0, 0, 0, 0)}, 0.2).Completed:Wait()
            if oldTab then oldTab.Frame.Visible = false end
            
            self.ActiveTab = newTab
            isTweeningTab = false
        end)
        
        -- This logic ensures the first tab created is the one that's active on load
        if not self.ActiveTab then
            newTab.Button.BackgroundColor3 = Theme.Accent
            newTab.Indicator.Visible = true
            newTab.Frame.Visible = true
            newTab.Frame.Position = UDim2.new(0,0,0,0)
            self.ActiveTab = newTab
        end
        
        self.Tabs[name] = newTab
        self.CurrentTabForCreation = newTab -- Set context for the AddElement functions
        return self
    end
    
    -- // Element Creation Functions
    function self:AddElement(height, isDropdown) 
        if not self.CurrentTabForCreation then warn("GlitchizUI: No tab has been created to add elements to."); return end
        
        local tab = self.CurrentTabForCreation
        local elementFrame = Create("Frame", {
            Size = UDim2.new(1, -30, 0, height),
            BackgroundTransparency = 1,
            LayoutOrder = tab.ElementOffset,
            ClipsDescendants = not isDropdown, -- Don't clip dropdowns so their options can appear
            Parent = tab.Frame
        })
        tab.ElementOffset = tab.ElementOffset + height + 10
        tab.Frame.CanvasSize = UDim2.new(0, 0, 0, tab.ElementOffset)
        return elementFrame
    end

    function self:AddLabel(labelProps) 
        local frame = self:AddElement(20)
        local label = Create("TextLabel",{
            Size = UDim2.new(1,0,1,0),
            Text = labelProps.Text or "Label",
            Font = labelProps.Bold and Theme.BoldFont or Theme.Font,
            TextSize = labelProps.Big and Theme.TextSize + 4 or Theme.TextSize,
            TextColor3 = labelProps.Color or Theme.Text,
            TextXAlignment = Enum.TextXAlignment.Left,
            BackgroundTransparency = 1,
            Parent = frame
        })
        local labelObject = {}
        function labelObject:Set(newText) label.Text = newText end
        return labelObject
    end

    function self:AddDivider() 
        local frame = self:AddElement(8)
        Create("Frame", { Size=UDim2.new(1,0,0,1), Position=UDim2.new(0.5,0,0.5,0), AnchorPoint=Vector2.new(0.5,0.5), BackgroundColor3=Theme.Accent, BackgroundTransparency=0.5, BorderSizePixel=0, Parent=frame})
    end

    function self:AddButton(buttonProps) 
        local frame = self:AddElement(35)
        local button = Create("TextButton", { Name="Button", Size=UDim2.new(1,0,1,0), Text=buttonProps.Text or "Button", Font=Theme.Font, TextSize=Theme.TextSize, TextColor3=Theme.Text, BackgroundColor3=Theme.Header, Parent=frame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=button})
        local stroke = Create("UIStroke", {Color=Theme.Accent, Parent=button})
        
        if buttonProps.Callback then button.MouseButton1Click:Connect(function() pcall(buttonProps.Callback) end) end
        button.MouseEnter:Connect(function() Animate(stroke, {Color=Theme.Accent2}) end)
        button.MouseLeave:Connect(function() Animate(stroke, {Color=Theme.Accent}) end)
        return {}
    end

    function self:AddToggle(toggleProps) 
        local frame = self:AddElement(25)
        local toggleObject = {Value = toggleProps.Default or false}
        
        Create("TextLabel", {Size=UDim2.new(1,-35,1,0), Position=UDim2.new(0,35,0,0), Text=toggleProps.Text or "Toggle", Font=Theme.Font, TextSize=Theme.TextSize, TextColor3=Theme.Text, TextXAlignment=Enum.TextXAlignment.Left, BackgroundTransparency=1, Parent=frame})
        local button = Create("TextButton", {Name="Toggle", Size=UDim2.new(0,25,0,25), Position=UDim2.new(0,0,0.5,0), AnchorPoint=Vector2.new(0,0.5), BackgroundColor3=Theme.Header, Text="", Parent=frame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=button})
        local stroke = Create("UIStroke",{Color=Theme.Accent, Parent=button})
        local checkmark = Create("Frame",{Name="Checkmark", Size=UDim2.new(0.6,0,0.6,0), Position=UDim2.new(0.5,0,0.5,0), AnchorPoint=Vector2.new(0.5,0.5), BackgroundColor3=Theme.Accent2, Visible=toggleObject.Value, Parent=button})
        Create("UICorner", {CornerRadius=UDim.new(0,2), Parent=checkmark})

        button.MouseButton1Click:Connect(function()
            toggleObject.Value = not toggleObject.Value
            checkmark.Visible = toggleObject.Value
            if toggleProps.Callback then pcall(toggleProps.Callback, toggleObject.Value) end 
        end)
        button.MouseEnter:Connect(function() Animate(stroke, {Color=Theme.Accent2}) end)
        button.MouseLeave:Connect(function() Animate(stroke, {Color=Theme.Accent}) end)
        return toggleObject
    end

    function self:AddTextbox(textboxProps) 
        local frame = self:AddElement(35)
        local textboxObject = {}
        
        local boxFrame = Create("Frame", {Size=UDim2.new(1,0,1,0), BackgroundColor3=Theme.Header, Parent=frame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=boxFrame})
        Create("UIStroke", {Color=Theme.Accent, Parent=boxFrame})
        
        local textbox = Create("TextBox", {Name="Textbox", Size=UDim2.new(1,-85,1,0), Position=UDim2.new(0,5,0,0), Text=textboxProps.Default or"", PlaceholderText=textboxProps.Placeholder or"...", Font=Theme.Font, TextSize=Theme.TextSize, TextColor3=Theme.Text, BackgroundTransparency=1, ClearTextOnFocus=textboxProps.ClearOnFocus or false, Parent=boxFrame})
        local submitButton = Create("TextButton", {Name="Submit", Size=UDim2.new(0,70,0.8,0), Position=UDim2.new(1,-75,0.1,0), Text=textboxProps.ButtonText or"Submit", Font=Theme.Font, TextSize=Theme.TextSize-1, TextColor3=Theme.Text, BackgroundColor3=Theme.Accent, Parent=boxFrame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=submitButton})

        local function FireCallback() if textboxProps.Callback then pcall(textboxProps.Callback, textbox.Text) end end
        textbox.FocusLost:Connect(function(enterPressed) if enterPressed then FireCallback() end end)
        submitButton.MouseButton1Click:Connect(FireCallback)
        
        function textboxObject:GetText() return textbox.Text end
        function textboxObject:SetText(newText) textbox.Text = newText end
        return textboxObject
    end
    
    function self:AddSlider(sliderProps)
        local frame = self:AddElement(45)
        local min, max, value = sliderProps.Min or 0, sliderProps.Max or 100, sliderProps.Default or 50
        
        local label = Create("TextLabel", {Size=UDim2.new(1,0,0,20), Text=(sliderProps.Text or "Slider")..": "..math.floor(value), Font=Theme.Font, TextSize=Theme.TextSize, TextColor3=Theme.Text, TextXAlignment=Enum.TextXAlignment.Left, BackgroundTransparency=1, Parent=frame})
        local track = Create("Frame", {Name="Track", Size=UDim2.new(1,0,0,6), Position=UDim2.new(0,0,0,25), BackgroundColor3=Theme.Header, Parent=frame}); Create("UICorner",{Parent=track})
        local progress = Create("Frame", {Name="Progress", Size=UDim2.new((value-min)/(max-min), 0, 1, 0), BackgroundColor3=Theme.Accent2, Parent=track}); Create("UICorner",{Parent=progress})
        local handle = Create("Frame", {Name="Handle", Size=UDim2.new(0,12,0,12), Position=UDim2.new(1,0,0.5,0), AnchorPoint=Vector2.new(0.5,0.5), BackgroundColor3=Theme.Text, Parent=progress}); Create("UICorner",{CornerRadius=UDim.new(1,0), Parent=handle})
        
        local isDragging = false
        local inputChangedConnection, inputEndedConnection
        local function UpdateSlider(inputPosition) 
            local relativeX = inputPosition.X - track.AbsolutePosition.X
            local percentage = math.clamp(relativeX / track.AbsoluteSize.X, 0, 1)
            value = min + (max - min) * percentage
            Animate(progress, {Size=UDim2.new(percentage,0,1,0)}, 0.05)
            label.Text = (sliderProps.Text or "Slider") .. ": " .. math.floor(value)
            if sliderProps.Callback then pcall(sliderProps.Callback, value) end 
        end
        
        track.InputBegan:Connect(function(input) 
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
                isDragging = true
                UpdateSlider(input.Position)
                
                inputChangedConnection = UserInputService.InputChanged:Connect(function(changedInput) 
                    if isDragging and (changedInput.UserInputType == Enum.UserInputType.MouseMovement or changedInput.UserInputType == Enum.UserInputType.Touch) then 
                        UpdateSlider(changedInput.Position)
                    end 
                end)
                
                inputEndedConnection = UserInputService.InputEnded:Connect(function(endedInput) 
                    if endedInput.UserInputType == Enum.UserInputType.MouseButton1 or endedInput.UserInputType == Enum.UserInputType.Touch then 
                        isDragging = false
                        if inputChangedConnection then inputChangedConnection:Disconnect(); inputChangedConnection = nil end
                        if inputEndedConnection then inputEndedConnection:Disconnect(); inputEndedConnection = nil end 
                    end 
                end)
            end
        end)
        return {}
    end

    function self:AddDropdown(dropdownProps)
        local frame = self:AddElement(35, true) -- Pass 'true' to disable clipping for this element's frame
        local isOpen = false
        local maxDropdownHeight = 150
        local optionHeight = 32
        local totalOptionsHeight = #dropdownProps.Options * optionHeight + 4
        local visibleOptionsHeight = math.min(totalOptionsHeight, maxDropdownHeight)

        local mainButton = Create("TextButton", {Name="DropdownMain", Size=UDim2.new(1,0,1,0), Text="  ".. (dropdownProps.Default or "Select an Option"), Font=Theme.Font, TextSize=Theme.TextSize, TextColor3=Theme.Text, BackgroundColor3=Theme.Header, TextXAlignment=Enum.TextXAlignment.Left, Parent=frame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=mainButton}); Create("UIStroke", {Color=Theme.Accent, Parent=mainButton})
        
        local arrow = Create("TextLabel", {Name="Arrow", Size=UDim2.new(0,30,1,0), Position=UDim2.new(1,-30,0,0), BackgroundTransparency=1, Font=Theme.BoldFont, Text="▼", TextColor3=Theme.Text, TextSize=12, Parent=mainButton})
        
        local optionsFrame = Create("ScrollingFrame", {Name="Options", Size=UDim2.new(1,0,0,0), Position=UDim2.new(0,0,1,5), BackgroundColor3=Theme.Background, BackgroundTransparency=0.1, BorderSizePixel=0, ClipsDescendants=true, Visible=false, CanvasSize=UDim2.new(0,0,0,totalOptionsHeight), ScrollBarImageColor3=Theme.Accent2, ScrollBarThickness=4, ZIndex = 10, Parent=frame})
        Create("UICorner", {CornerRadius=UDim.new(0,4), Parent=optionsFrame}); Create("UIStroke", {Color=Theme.Accent, Parent=optionsFrame}); Create("UIListLayout", {Padding=UDim.new(0,4), Parent=optionsFrame})
        
        local function CloseDropdown()
            isOpen = false
            Animate(arrow, {Rotation = 0}) 
            Animate(frame, {Size = UDim2.new(1, -30, 0, 35)}, 0.2)
            local anim = Animate(optionsFrame, {Size=UDim2.new(1,0,0,0)}, 0.2)
            anim.Completed:Connect(function() optionsFrame.Visible=false end)
        end
        
        for _, optionText in ipairs(dropdownProps.Options or {}) do
            local optionButton = Create("TextButton", {Name=optionText, Size=UDim2.new(1,-8,0,28), Text="  "..optionText, Font=Theme.Font, TextSize=Theme.TextSize-1, TextColor3=Theme.Text, BackgroundColor3=Theme.Header, TextXAlignment=Enum.TextXAlignment.Left, AutoButtonColor=false, Parent=optionsFrame})
            Create("UICorner", {CornerRadius=UDim.new(0,2), Parent=optionButton})
            optionButton.MouseEnter:Connect(function() Animate(optionButton, {BackgroundColor3 = Theme.Accent}, 0.1) end)
            optionButton.MouseLeave:Connect(function() Animate(optionButton, {BackgroundColor3 = Theme.Header}, 0.1) end)
            optionButton.MouseButton1Click:Connect(function() 
                mainButton.Text = "  "..optionText
                CloseDropdown()
                if dropdownProps.Callback then pcall(dropdownProps.Callback, optionText) end 
            end)
        end
        
        mainButton.MouseButton1Click:Connect(function()
            isOpen = not isOpen
            Animate(arrow, {Rotation = isOpen and 180 or 0})
            if isOpen then 
                optionsFrame.Visible = true
                Animate(frame, {Size = UDim2.new(1, -30, 0, 35 + visibleOptionsHeight + 5)}, 0.2)
                Animate(optionsFrame, {Size=UDim2.new(1,0,0,visibleOptionsHeight)}, 0.2)
            else 
                CloseDropdown() 
            end
        end)
        return {}
    end

    return self
end

return Library
